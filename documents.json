[
  {
    "id": "doc_1757400721_e984fd8c",
    "name": "Compiler Lab Assignment - 3.pdf",
    "type": "pdf",
    "size": 443834,
    "upload_date": "2025-09-09T06:52:01.476547",
    "content": "Compiler Lab Assign ment \u2013 3 \nName: Pranav Murali  \nReg. No: 22BCE3161  \n1) Simple Calculat or \ncalc.y  \n%{ \n#include <stdio.h>  \n#include <stdlib.h>  \nint yylex(void);  \nvoid yyerror(const char *s);  \n%} \n \n%union { int ival; }  \n \n%token <ival> NUMBER  \n%right NEG  \n%left '+' ' -' \n%left '*' '/' '%'  \n%right '^'  \n \n%type <ival> expr line  \n \n%%  \n \ninput:  \n    /* empty */  \n  | input line  \n  ; \n \nline:  \n    expr '\\n'            { printf(\"%d valid expression \\n\", $1); }  \n  | '\\n'                 { /* blank line */ }  \n  | error '\\n'           { yyerrok; printf(\"Invalid expression \\n\"); }  \n  ; \n \nexpr:  \n    NUMBER               { $$ = $1; }  \n  | '-' expr %prec NEG   { $$ = -$2; }  \n  | expr '+' expr        { $$ = $1 + $3; }  \n  | expr '-' expr        { $$ = $1 - $3; }  \n  | expr '*' expr        { $$ = $1 * $3; }  \n  | expr '/' expr        { if ($3==0) { yyerror(\"div by zero\"); $$=0; } else $$ = $1 / $3; }  \n  | expr '%' expr        { $$ = $1 % $3; }  \n  | expr '^' expr        { int i,res=1; for(i=0;i<$3;i++) res*=$1; $$=res; }  \n  ; \n \n%%  \n \nvoid yyerror(const char *s) { /* handled in grammar */ }  \nint main(void) { return yyparse(); }  \ncalc.l \n%option noyywrap  \n%{ \n#include \"calc.tab.h\"  \n#include <stdlib.h>  \n%} \n \n%%  \n[0-9]+      { yylval.ival = atoi(yytext); return NUMBER; }  \n\"^\"         { return '^'; }  \n[+\\-*/%]    { return yytext[0]; }  \n\\n          { return ' \\n'; }  \n[ \\t]       { /* ignore spaces */ }  \n.           { return yytext[0]; }  /* invalid char passes to parser */  \n%%  \nInput.txt  \n4+5*2  \n8%3+7  \n-5 \n4*8/2  \n42+32  \n6++2  \n6-4 \nOutput  \n \n2) String Recognizer (a\u207fb\u207f: a, ab, aabb, aaabbb, \u2026)  \nstr.y  \n%{ \n#include <stdio.h>  \nint yylex(void);  \nvoid yyerror(const char *s);  \n%} \n \n\n/* No %token needed for character literals 'a','b',' \\n' */  \n \n%%  \n \ninput:  \n      /* empty */  \n    | input line  \n    ; \n \nline:  \n      s '\\n'        { printf(\"valid string \\n\"); }  \n    | '\\n'          { /* blank */ }  \n    | error '\\n'    { yyerrok; printf(\"invalid string \\n\"); }  \n    ; \n \n/* Language = { \"a\" } \u222a { a^n b^n | n >= 1 } */  \ns: \n      only_a  \n    | anbn  \n    ; \n \nonly_a:  \n      'a' \n    ; \n \n/* a^n b^n with n >= 1 */  \nanbn:  \n      'a' 'b'  \n    | 'a' anbn 'b'  \n    ; \n \n%%  \n \nvoid yyerror(const char *s) { /* no -op */ }  \nint main(void) { printf(\"enter the string \\n\"); return yyparse(); }  \nstr.l  \n%option noyywrap  \n%{ \n#include \"str.tab.h\"  \n%} \n \n%%  \na   { return 'a'; }  \nb   { return 'b'; }  \n\\n  { return ' \\n'; }  \n[ \\t] { /* ignore */ }  \n.   { return yytext[0]; }  \n%%  \nOutput  \n \n \n \n \n\n3) Token Recognizer (identifiers, keywords, operators) for C text  \ntokens.y  \n%{ \n#include <stdio.h>  \n#include <stdlib.h>  \nint yylex(void);  \nvoid yyerror(const char *s);  \n%} \n \n%union { char *sval; }  \n \n%token <sval> IDENTIFIER NUMBER KEYWORD OPERATOR UNKNOWN  \n \n%%  \n \ninput:  \n      /* empty */  \n    | input token  \n    ; \n \ntoken:  \n      IDENTIFIER { printf(\"%s : identifier \\n\", $1); free($1); }  \n    | NUMBER     { printf(\"%s : number \\n\", $1); free($1); }  \n    | KEYWORD    { printf(\"%s : keyword \\n\", $1); free($1); }  \n    | OPERATOR   { printf(\"%s : operator \\n\", $1); free($1); }  \n    | UNKNOWN    { printf(\"%s : unknown \\n\", $1); free($1); }  \n    ; \n \n%%  \n \nvoid yyerror(const char *s) {  \n    fprintf(stderr, \"Parse error: %s \\n\", s);  \n} \nint main(void) { return yyparse(); }  \ntokens.l  \n%{ \n#include \"tokens.tab.h\"  \n#include <string.h>  \n#include <stdlib.h>  \nint yywrap(void){ return 1; }  \n%} \n \n%%  \n/* Keywords */  \nauto        { yylval.sval=strdup(yytext); return KEYWORD; }  \nbreak       { yylval.sval=strdup(yytext); return KEYWORD; }  \ncase        { yylval.sval=strdup(yytext); return KEYWORD; }  \nchar        { yylval.sval=strdup(yytext); return KEYWORD; }  \nconst       { yylval.sval=strdup(yytext); return KEYWORD; }  \ncontinue    { yylval.sval=strdup(yytext); return KEYWORD; }  \ndefault     { yylval.sval=strdup(yytext); return KEYWORD; }  \ndo          { yylval.sval=strdup(yytext); return KEYWORD; }  \ndouble      { yylval.sval=strdup(yytext); return KEYWORD; }  \nelse        { yylval.sval=strdup(yytext); return KEYWORD; }  \nenum        { yylval.sval=strdup(yytext); return KEYWORD; }  \nextern      { yylval.sval=strdup(yytext); return KEYWORD; }  \nfloat       { yylval.sval=strdup(yytext); return KEYWORD; }  \nfor         { yylval.sval=strdup(yytext); return KEYWORD; }  \ngoto        { yylval.sval=strdup(yytext); return KEYWORD; }  \nif          { yylval.sval=strdup(yytext); return KEYWORD; }  \nint         { yylval.sval=strdup(yytext); return KEYWORD; }  \nlong        { yylval.sval=strdup(yytext); return KEYWORD; }  \nregister    { yylval.sval=strdup(yytext); return KEYWORD; }  \nreturn      { yylval.sval=strdup(yytext); return KEYWORD; }  \nshort       { yylval.sval=strdup(yytext); return KEYWORD; }  \nsigned      { yylval.sval=strdup(yytext); return KEYWORD; }  \nsizeof      { yylval.sval=strdup(yytext); return KEYWORD; }  \nstatic      { yylval.sval=strdup(yytext); return KEYWORD; }  \nstruct      { yylval.sval=strdup(yytext); return KEYWORD; }  \nswitch      { yylval.sval=strdup(yytext); return KEYWORD; }  \ntypedef     { yylval.sval=strdup(yytext); return KEYWORD; }  \nunion       { yylval.sval=strdup(yytext); return KEYWORD; }  \nunsigned    { yylval.sval=strdup(yytext); return KEYWORD; }  \nvoid        { yylval.sval=strdup(yytext); return KEYWORD; }  \nvolatile    { yylval.sval=strdup(yytext); return KEYWORD; }  \n \n/* Operators */  \n\"==\"|\"!=\"|\"<=\"|\">=\"|\"<<\"|\">>\"|\"&&\"|\"||\"|\"++\"|\" --\"|\"+=\"|\"-=\"|\"*=\"|\"/=\"|\"%=\"  \n            { yylval.sval=strdup(yytext); return OPERATOR; }  \n[+\\-*/%=&<>!~^|?:;, \\[\\]\\(\\)\\{\\}] \n            { yylval.sval=strdup(yytext); return OPERATOR; }  \n \n/* Identifiers and numbers */  \n[0-9]+                  { yylval.sval=strdup(yytext); return NUMBER; }  \n[a-zA-Z_][a-zA-Z0-9_]*  { yylval.sval=strdup(yytext); return IDENTIFIER; }  \n \n/* Ignore whitespace */  \n[ \\t\\r\\n]+              { /* skip */ }  \n \n/* Fallback */  \n.                       { yylval.sval=strdup(yytext); return UNKNOWN; }  \n%%  \nsample.c \nint main() {  \n  int a = 5;  \n  if (a > 0) return a;  \n} \nOutput",
    "status": "ready"
  },
  {
    "id": "doc_1757400963_8b1f436b",
    "name": "Compiler Lab Assignment - 3.pdf",
    "type": "pdf",
    "size": 443834,
    "upload_date": "2025-09-09T06:56:03.370614",
    "content": "Compiler Lab Assign ment \u2013 3 \nName: Pranav Murali  \nReg. No: 22BCE3161  \n1) Simple Calculat or \ncalc.y  \n%{ \n#include <stdio.h>  \n#include <stdlib.h>  \nint yylex(void);  \nvoid yyerror(const char *s);  \n%} \n \n%union { int ival; }  \n \n%token <ival> NUMBER  \n%right NEG  \n%left '+' ' -' \n%left '*' '/' '%'  \n%right '^'  \n \n%type <ival> expr line  \n \n%%  \n \ninput:  \n    /* empty */  \n  | input line  \n  ; \n \nline:  \n    expr '\\n'            { printf(\"%d valid expression \\n\", $1); }  \n  | '\\n'                 { /* blank line */ }  \n  | error '\\n'           { yyerrok; printf(\"Invalid expression \\n\"); }  \n  ; \n \nexpr:  \n    NUMBER               { $$ = $1; }  \n  | '-' expr %prec NEG   { $$ = -$2; }  \n  | expr '+' expr        { $$ = $1 + $3; }  \n  | expr '-' expr        { $$ = $1 - $3; }  \n  | expr '*' expr        { $$ = $1 * $3; }  \n  | expr '/' expr        { if ($3==0) { yyerror(\"div by zero\"); $$=0; } else $$ = $1 / $3; }  \n  | expr '%' expr        { $$ = $1 % $3; }  \n  | expr '^' expr        { int i,res=1; for(i=0;i<$3;i++) res*=$1; $$=res; }  \n  ; \n \n%%  \n \nvoid yyerror(const char *s) { /* handled in grammar */ }  \nint main(void) { return yyparse(); }  \ncalc.l \n%option noyywrap  \n%{ \n#include \"calc.tab.h\"  \n#include <stdlib.h>  \n%} \n \n%%  \n[0-9]+      { yylval.ival = atoi(yytext); return NUMBER; }  \n\"^\"         { return '^'; }  \n[+\\-*/%]    { return yytext[0]; }  \n\\n          { return ' \\n'; }  \n[ \\t]       { /* ignore spaces */ }  \n.           { return yytext[0]; }  /* invalid char passes to parser */  \n%%  \nInput.txt  \n4+5*2  \n8%3+7  \n-5 \n4*8/2  \n42+32  \n6++2  \n6-4 \nOutput  \n \n2) String Recognizer (a\u207fb\u207f: a, ab, aabb, aaabbb, \u2026)  \nstr.y  \n%{ \n#include <stdio.h>  \nint yylex(void);  \nvoid yyerror(const char *s);  \n%} \n \n\n/* No %token needed for character literals 'a','b',' \\n' */  \n \n%%  \n \ninput:  \n      /* empty */  \n    | input line  \n    ; \n \nline:  \n      s '\\n'        { printf(\"valid string \\n\"); }  \n    | '\\n'          { /* blank */ }  \n    | error '\\n'    { yyerrok; printf(\"invalid string \\n\"); }  \n    ; \n \n/* Language = { \"a\" } \u222a { a^n b^n | n >= 1 } */  \ns: \n      only_a  \n    | anbn  \n    ; \n \nonly_a:  \n      'a' \n    ; \n \n/* a^n b^n with n >= 1 */  \nanbn:  \n      'a' 'b'  \n    | 'a' anbn 'b'  \n    ; \n \n%%  \n \nvoid yyerror(const char *s) { /* no -op */ }  \nint main(void) { printf(\"enter the string \\n\"); return yyparse(); }  \nstr.l  \n%option noyywrap  \n%{ \n#include \"str.tab.h\"  \n%} \n \n%%  \na   { return 'a'; }  \nb   { return 'b'; }  \n\\n  { return ' \\n'; }  \n[ \\t] { /* ignore */ }  \n.   { return yytext[0]; }  \n%%  \nOutput  \n \n \n \n \n\n3) Token Recognizer (identifiers, keywords, operators) for C text  \ntokens.y  \n%{ \n#include <stdio.h>  \n#include <stdlib.h>  \nint yylex(void);  \nvoid yyerror(const char *s);  \n%} \n \n%union { char *sval; }  \n \n%token <sval> IDENTIFIER NUMBER KEYWORD OPERATOR UNKNOWN  \n \n%%  \n \ninput:  \n      /* empty */  \n    | input token  \n    ; \n \ntoken:  \n      IDENTIFIER { printf(\"%s : identifier \\n\", $1); free($1); }  \n    | NUMBER     { printf(\"%s : number \\n\", $1); free($1); }  \n    | KEYWORD    { printf(\"%s : keyword \\n\", $1); free($1); }  \n    | OPERATOR   { printf(\"%s : operator \\n\", $1); free($1); }  \n    | UNKNOWN    { printf(\"%s : unknown \\n\", $1); free($1); }  \n    ; \n \n%%  \n \nvoid yyerror(const char *s) {  \n    fprintf(stderr, \"Parse error: %s \\n\", s);  \n} \nint main(void) { return yyparse(); }  \ntokens.l  \n%{ \n#include \"tokens.tab.h\"  \n#include <string.h>  \n#include <stdlib.h>  \nint yywrap(void){ return 1; }  \n%} \n \n%%  \n/* Keywords */  \nauto        { yylval.sval=strdup(yytext); return KEYWORD; }  \nbreak       { yylval.sval=strdup(yytext); return KEYWORD; }  \ncase        { yylval.sval=strdup(yytext); return KEYWORD; }  \nchar        { yylval.sval=strdup(yytext); return KEYWORD; }  \nconst       { yylval.sval=strdup(yytext); return KEYWORD; }  \ncontinue    { yylval.sval=strdup(yytext); return KEYWORD; }  \ndefault     { yylval.sval=strdup(yytext); return KEYWORD; }  \ndo          { yylval.sval=strdup(yytext); return KEYWORD; }  \ndouble      { yylval.sval=strdup(yytext); return KEYWORD; }  \nelse        { yylval.sval=strdup(yytext); return KEYWORD; }  \nenum        { yylval.sval=strdup(yytext); return KEYWORD; }  \nextern      { yylval.sval=strdup(yytext); return KEYWORD; }  \nfloat       { yylval.sval=strdup(yytext); return KEYWORD; }  \nfor         { yylval.sval=strdup(yytext); return KEYWORD; }  \ngoto        { yylval.sval=strdup(yytext); return KEYWORD; }  \nif          { yylval.sval=strdup(yytext); return KEYWORD; }  \nint         { yylval.sval=strdup(yytext); return KEYWORD; }  \nlong        { yylval.sval=strdup(yytext); return KEYWORD; }  \nregister    { yylval.sval=strdup(yytext); return KEYWORD; }  \nreturn      { yylval.sval=strdup(yytext); return KEYWORD; }  \nshort       { yylval.sval=strdup(yytext); return KEYWORD; }  \nsigned      { yylval.sval=strdup(yytext); return KEYWORD; }  \nsizeof      { yylval.sval=strdup(yytext); return KEYWORD; }  \nstatic      { yylval.sval=strdup(yytext); return KEYWORD; }  \nstruct      { yylval.sval=strdup(yytext); return KEYWORD; }  \nswitch      { yylval.sval=strdup(yytext); return KEYWORD; }  \ntypedef     { yylval.sval=strdup(yytext); return KEYWORD; }  \nunion       { yylval.sval=strdup(yytext); return KEYWORD; }  \nunsigned    { yylval.sval=strdup(yytext); return KEYWORD; }  \nvoid        { yylval.sval=strdup(yytext); return KEYWORD; }  \nvolatile    { yylval.sval=strdup(yytext); return KEYWORD; }  \n \n/* Operators */  \n\"==\"|\"!=\"|\"<=\"|\">=\"|\"<<\"|\">>\"|\"&&\"|\"||\"|\"++\"|\" --\"|\"+=\"|\"-=\"|\"*=\"|\"/=\"|\"%=\"  \n            { yylval.sval=strdup(yytext); return OPERATOR; }  \n[+\\-*/%=&<>!~^|?:;, \\[\\]\\(\\)\\{\\}] \n            { yylval.sval=strdup(yytext); return OPERATOR; }  \n \n/* Identifiers and numbers */  \n[0-9]+                  { yylval.sval=strdup(yytext); return NUMBER; }  \n[a-zA-Z_][a-zA-Z0-9_]*  { yylval.sval=strdup(yytext); return IDENTIFIER; }  \n \n/* Ignore whitespace */  \n[ \\t\\r\\n]+              { /* skip */ }  \n \n/* Fallback */  \n.                       { yylval.sval=strdup(yytext); return UNKNOWN; }  \n%%  \nsample.c \nint main() {  \n  int a = 5;  \n  if (a > 0) return a;  \n} \nOutput",
    "status": "ready"
  }
]